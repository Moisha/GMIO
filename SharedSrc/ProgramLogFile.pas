////////////////////////////////////////////
// Логи
////////////////////////////////////////////
unit ProgramLogFile;

interface

uses Windows, Classes, GMGlobals, SysUtils, EsLogging;

type
  TProgramLogFile = class
  private
    function NeedComLog: bool;
    function NeedExchangeBuf: bool;
    procedure PostLogMessage(const Msg: string);
  protected
    FLogger: TesLogger;
  public
    procedure AddMessage(const s: string);
    procedure AddError(const s: string);
    procedure AddException(const s: string);
    procedure AddExchangeBuf(const s: string); overload;
    procedure AddExchangeBuf(const comDevice: string; direction: int; buf: array of Byte; bufLen: int); overload;
    procedure AddExchangeBuf(const comDevice: string; direction: int; const buf: string); overload;

    constructor Create();
    destructor Destroy; override;
  end;

  function ProgramLog(): TProgramLogFile;

implementation

uses GMConst, Forms, JclDebug;

function JCLLastExceptionCallStack(): string;
var sl: TStringList;
begin
  sl := TStringList.Create();
  try
    JclLastExceptStackListToStrings(sl, true, true, true, true);
    Result := sl.Text;
  finally
    sl.Free();
  end;
end;

var applicationProgramLog: TProgramLogFile = nil;
    LogSynch: TMultiReadExclusiveWriteSynchronizer;

function ProgramLog(): TProgramLogFile;
begin
  LogSynch.BeginWrite();
  try
    if applicationProgramLog = nil then
      applicationProgramLog := TProgramLogFile.Create();

    Result := applicationProgramLog;
  finally
    LogSynch.EndWrite();
  end;
end;

{ TProgramLogFile }

procedure TProgramLogFile.PostLogMessage(const Msg: string);
begin
{$ifdef MESSAGE_COM_LOG}
  if (Application <> nil) and (Application.MainForm <> nil) then
    GMPostMessage(WM_UPDATE_COM_LOG, WPARAM(TStringClass.Create(Msg)), 0, DefaultLogger);
{$endif}
end;

procedure TProgramLogFile.AddError(const s: string);
begin
  FLogger.Error(s);
  PostLogMessage(s);
end;

procedure TProgramLogFile.AddExchangeBuf(const comDevice: string; direction: int; buf: array of Byte; bufLen: int);
var s: string;
begin
  if not NeedExchangeBuf() then Exit;

  case direction of
    COM_LOG_IN: s := '<';
    COM_LOG_OUT: s := '?';
    else s := '';
  end;

  s := s + #9 + comDevice + #9 + IntToStr(bufLen) + #9 + ArrayToString(buf, bufLen, true, true);
  AddExchangeBuf(s);
end;

procedure TProgramLogFile.AddException(const s: string);
begin
  AddError(s + #13#10 + JCLLastExceptionCallStack());
end;

procedure TProgramLogFile.AddExchangeBuf(const comDevice: string; direction: int; const buf: string);
var s: string;
begin
  if not NeedExchangeBuf() then Exit;

  case direction of
    COM_LOG_IN: s := '<';
    COM_LOG_OUT: s := '?';
    else s := '';
  end;

  s := s + #9 + comDevice + #9 + IntToStr(Length(buf)) + #9 + buf;
  AddExchangeBuf(s);
end;

procedure TProgramLogFile.AddExchangeBuf(const s: string);
begin
  FLogger.Debug(s);
  PostLogMessage(s);
end;

procedure TProgramLogFile.AddMessage(const s: string);
begin
  FLogger.Info(s);
  PostLogMessage(s);
end;

function TProgramLogFile.NeedExchangeBuf: bool;
begin
  Result := NeedComLog();
end;

function TProgramLogFile.NeedComLog: bool;
begin
  Result := true;
end;

constructor TProgramLogFile.Create;
begin
  FLogger := TesLogging.GetLogger('Default');
end;

destructor TProgramLogFile.Destroy;
begin

  inherited;
end;

initialization
  LogSynch := TMultiReadExclusiveWriteSynchronizer.Create();

  // Enable raw mode (default mode uses stack frames which aren't always generated by the compiler)
  Include(JclStackTrackingOptions, stRawMode);
  // Disable stack tracking in dynamically loaded modules (it makes stack tracking code a bit faster)
  Include(JclStackTrackingOptions, stStaticModuleList);
  // Initialize Exception tracking
  JclStartExceptionTracking();

finalization
  JclStopExceptionTracking();

  TryFreeAndNil(applicationProgramLog);
  LogSynch.Free();
end.
